Задание 4.

Задания делятся на два уровня - попроще и посложнее. Выбирайте сами, что вы можете сделать.


===== ПОЛЕГЧЕ   ======
Задание 4-1. Случайности - не случайны

Создать класс SequentialRandom с одним полем типа int. Это - immutable класс-контейнер для целого числа.
immutable - это классы, значения полей которых нельзя изменить.

Значение поля можно только прочитать, но не изменить (используйте модифиактор private на поле и создайте только getter)
Значение этого int вычисляется по следующим правилом:
- Значение для первого созданного объекта - случайное
- значение для каждого следующего на 1 больше, чем предыдущее
- У класса есть статический метод resetRandom(), который делает значение следующего созданного объекта - случайным.

Например
new SequentialRandom() // содержит 5 (случайное)
new SequentialRandom() // содержит 6 (на 1 больше)
new SequentialRandom() // содержит 7 (на 1 больше)
SequentialRandom.resetRandom()
new SequentialRandom() // содержит 42 (случайное
new SequentialRandom() // содержит 43) (на 1  больше)

Подсказка: Используйте статическую переменную в классе, чтобы хранить значение предыдущего объекта.






Задание 4-2. Фруктовая неоднозначность
Создать класс Fruit со свойством "вес" типа int и методом toString
Создать наследники:
Apple - с дополнительным свойством цвет (красное, зеленое, желтое) - String
Orange - с дополнительном свойством толщина кожуры - int от 0 до 20
Pineapple - с дополнительным свойством - высота хвоста - int, от 5 до 20

переопределить во всех фруктах toString, чтобы выводил все свойства фрукта и тип фрукта (яблоко, апельсин, ананас)

создать метод getRandomFruit - которое возвращает случаный фрукт со случайными характеристиками.

Обратите внимание, если у вас есть переменная с типом родительского класса,
то в такую переменную можно записывать переменные дочерних классов, например:
Parent parent = new Child();
валидный код, при условии, что class Child extends Parent {...}

Создать массив типа Fruit, заполнить его 4 разными случаными фруктами и вывести их на экран





Задание 4-3. Абстрактный супрематизм

Создать класс Figure, описывающий фигуру на двумерной плоскости с декартовыми координатами центра x,y.
В классе объявить метод square, который вычисляет площадь фигуры. В самом классе Figure метод ничего не делает, поведение определяется в классе-наследниках.
В классе объявить и реализовать метод getQuadrant(), который возвращает четверть на координатной плоскости, в которой лежит центр фигуры.
Для описания четверти используйте int с четырьями значениями: 1,2,3,4. Если четверть определить не удалось - верните -1.

Создать классы-наследники:
Circle - дополнительный параметр радиус, от 1 до 10
Square - дополнительный параметр - длина стороны,от 1 до 10.
IsoscelesTriangle - дополнительные параметры высота и основание, от 1 до 10.

В каждом классе определить метод square, чтобы он правильно считал площадь.

в main'e создать массив на 5 элементов типа Figure, заполните любыми фигурами (не обязательно случайными), выведите все фигуры в формате
"Название фигуры - площадь"






===== ПОСЛОЖНЕЕ ======
Задание 4-4. Битвы магов.

Есть сцена (Scene).
На сцену можно добавить до 10 Персонажей (Character)
у каждого персонажа есть позиция (от 0 до 9). На которой он стоит. На позиции с одинаковым номером может стоять только один персонаж.
В позициях допускаются пропуски, например, на сцене могут быть всего два персонажа: на позиции 1 и на позиции 7. 

У абстрактного персонажа есть характеристики:
- Текущее здоровье: целое число
- Имя: строка

Если текущее здоровье у персонажа стало отрицательным - он удаляется со сцены и на экран выводится текст "<имя персонажа> убит"

Конкретные персонажи бывают двух типов:
Монстры. Могут атаковать любого персонажа, напрямую нанося урон здоровью.
Количество урона для каждого конкретного монстра одинаковое, но разные экземпляры монстров могут наносить разное количество урона.
Если монстр атакует любого персонажа, - на экран должен выводится текст "Монстр <имя> атакует <имя, цели> на <количество> единиц урона урона "
Маги. Могут колдовать заклинания. Заклинания могут делать что угодно со сценой и персонажами на ней. 

У каждого мага есть список заклинаний (книга заклинаний), которые он может использовать, но не больше 3.
Создайте класс Spell с методом cast - произнесение заклинания и полем "название заклинания". 


Создайте несколько конкретных заклинаний. Например:
Исцеление - добавляет очков здоровья магу, произнесшему заклинания. 
Молния - наносит урон любому персонажу.
Цепная молния - наносит урон, всем персонажам на сцене, кроме мага, который произносит заклинание.
Стена огня - наносит урон всем персонажам на четных позициях. 
Огненное касание - наносит урон персонажу, стоящему на соседней с магом позиции.
Если на соседних позициях персонажей нет - никому урон не наносится. 
Изгнание монстров - наносит урон всем монстрам.
Мигрень - наносит урон всем магам.

Если маг произносит любое заклинание то экран обязательно должен выводится общий текст для всех заклинаний:
"Маг <имя> читает заклинание <название заклинания>"

+ дополнительно должен быть выведен текст, зависящий от заклинания. 
Например
"Маг Merlin читает заклинание Исцеление."
"Маг Merlin исцелен на 12. Теперь у него 20 здоровья"

"Маг Merlin читает заклинание Цепная Молния."
"Цепная молния ударяет по Трус, Бывалый, Балбес. Каждый получает 5 урона."

Игра - пошаговая. В каждый ход все персонажи со сцены делают одно действие: 
монстр атакует кого-то, а маг читает любое известное ему заклинание.

Порядок, в котором персонажи выполняют действия может быть любым, например по номеру позиции или как вы сами решите.  
Каждый персонаж сам за себя, если на сцене остался только один персонаж - то игра завершается и на экран выводится имя и тип (маг, монстр) победившего персонажа.

Создайте сцену со случайным количеством случайных персонажей, запустите игру.

Замечания к заданию:
Обратите внимание, что многие вещи я намеренно не стал детализировать.
Например, в каких классах располагаются методы, отвечающие за нанесение урона и вывод сообщений на экран,
кто управляет сценой и ходами, как происходит генерация начальной сцены, какая книга заклинаний будет у каждого мага,
кого атакуют монстры или какое заклинание читает маг и т.п. 

Ваша задача - проанализировать требования и сделать такую структуру классов, которая наиболее гибко будет решать эти требованиях. 

При проектировании структуры классов помните про "правила хорошего программирования":
- Дублирование кода обычно плохо
- Код должен быть простым и расширяемым.

Например, что будет, если в игру добавится новый персонаж с какими-то новыми способностями ( рыцарь, который от всех заклинаний получает только половину урона или разбойник, который имеет некоторый шанс уклониться от атаки монстра)?
- Пользуйтесь отладчиком, вот здесь видео, где подробно рассказано, как это сделать https://www.youtube.com/watch?v=Z1BQsf0A4xY


