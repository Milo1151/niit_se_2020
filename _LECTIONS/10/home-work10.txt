Задание 10. Гонки по лабиринту

Задача состоит из двух частей:
- Генерация двумерного лабиринта. Тут каких-то ограничений нет. Но следите, чтобы лабиринт был проходимым - из любой его клетки можно будет пройти в любую другую клетку.
Рекомендую хранить лабиринт в виде двумерного массива: boolean[][] maze
Индексы - это координаты, а значение в массива - является ли участок лабиринта с переданными координатами стеной или проходом.

Можете взять какой-то готовый лабиринт или генерировать его самостоятельно - в интернете есть много алгоритмов генерации.

Вторая часть - непосредственно гонка.
Есть несколько участников-потоков. Они одновременно начинают проходить лабиринт.

Есть две случайные точки:
- Старт.
- Финиш.
Обе точки должны быть проходимыми (не стенами).

У участника есть поля:
- Имя участника
- Ссылка на лабиринт. Все участники знают план лабиринта
- Текущая позиция. Изначально - старт, но с каждом ходом изменяется.
- Координаты финиша - у всех участников в рамках одной и той же гонки они одинаковые.

У участника есть метод boolean step(); возвращает true, если участник оказался в точке финиша, false в противном случае.
Этот метод может переместить участника на одну соседнюю с текущией позицией клетку. На стены перемещаться нельзя.

+ все участники должны записывать свой маршрут.

Когда какой-то участник дойдет до финиша, на экран нужно вывести имя участника, время прохождения маршрута и количество пройденных участником "шагов".

Когда все участники пройдут лабиринт - на экран нужно вывести имя участника, сделавшего наименьшее количество шагов.
Этот участник получает отдельный приз.
Заметьте, что предположение "если сделал меньше шагов - то и пришел первее всех" не всегда верное.
Учитывая, что в дело вступает многопоточность - некоторые участники за один квант времени могут делать количество шагов большее, чем другие участники.

Алгоритм прохождения лабиринт можете выбирать какой хотите, например- случайное перемещение в рядом стояющую точку.
или пользоваться правилом правой\левой руки, если у вас будет односвязный алгоритм.